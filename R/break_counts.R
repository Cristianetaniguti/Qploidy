globalVariables(c("."))

#' Count number of recombination breakpoints in parents gametes
#'
#' @param homoprob object of class mappoly.homoprob
#' @param aneuploids data.frame with each chromosome ploidy
#' @param ped.file path to csv file containing three columns: 1) Sample ID, 2) Parent1 ID, 3) Parent2 ID
#' @param inds vector with individuals to be evaluated
#'
#' @import tidyr
#' @import dplyr
#' @importFrom utils read.csv
#'
#' @export
count_breaks_df <- function(homoprob,
                            aneuploids = NULL,
                            inds = NULL,
                            ped.file = NULL){

  homoprob$LG <- paste0("Chr", homoprob$LG)
  homoprob$most_likely <- homoprob$probability
  homoprob$most_likely[which(homoprob$probability > 0.5)] <- 1
  homoprob$most_likely[which(homoprob$probability <= 0.5)] <- 0
  homoprob$parent <- NA
  ploidy <- length(unique(homoprob$homolog))/2

  if(is.null(ped.file)){
    homoprob$parent[which(homoprob$homolog %in% letters[1:ploidy])] <- "P1"
    homoprob$parent[which(homoprob$homolog %in% letters[(ploidy+1):(2*ploidy)])] <- "P2"
  } else {
    ped <- read.csv(ped.file)
    p1 <- ped[match(homoprob$individual[which(homoprob$homolog %in% letters[1:ploidy])], ped$id),2]
    p2 <- ped[match(homoprob$individual[which(homoprob$homolog %in% letters[(ploidy+1):(2*ploidy)])], ped$id),3]
    homoprob$parent[which(homoprob$homolog %in% letters[1:ploidy])] <- p1
    homoprob$parent[which(homoprob$homolog %in% letters[(ploidy+1):(2*ploidy)])] <- p2
  }

  if(!is.null(inds)) homoprob <- homoprob %>% filter(.data$individual %in% inds)

  counts <- homoprob %>% group_by(.data$individual, .data$LG, .data$parent, .data$homolog) %>%
    summarize(counts = sum(sequence(rle(as.character(.data$most_likely))$length) == 1) - 1) %>%
    group_by(.data$individual, .data$LG, .data$parent) %>%
    summarize(total_counts = sum(.data$counts))

  if(!is.null(aneuploids)){
    aneuploids <- pivot_longer(as.data.frame(aneuploids), cols = 2:ncol(aneuploids), values_to = "ploidy", names_to = "LG")
    colnames(aneuploids)[1] <- c("individual")
    counts <- merge(counts, aneuploids, by = c("individual", "LG"))
  }
  return(counts)
}

#' Plot break counts
#'
#' @param counts data.frame generated by count_breaks_df
#' @param n.graphics define number of graphics
#' @param ncol define number of columns
#' @param by_LG FALSE if colors by ploidy, TRUE if colors by group
#'
#' @import ggplot2
#' @importFrom RColorBrewer brewer.pal
#' @importFrom grDevices colorRampPalette
#' @importFrom ggpubr ggarrange
#' @import dplyr
#'
#' @export
count_breaks_plot <- function(counts,
                              n.graphics=NULL,
                              ncol=NULL,
                              by_LG = TRUE){
  p <- list()
  n.ind <- length(unique(counts$individual))

  if(is.null(n.graphics) & is.null(ncol)){
    if(n.ind/25 <= 1) {
      n.graphics = 1
      ncol=1
    }else {
      n.graphics = round(n.ind/25,0)
      ncol=round(n.ind/25,0)
    }
  }

  size <-n.ind
  if(size%%n.graphics == 0){
    div.n.graphics <- rep(1:n.graphics, each= size/n.graphics)
  } else {
    div.n.graphics <-   c(rep(1:n.graphics, each = round(size/n.graphics,0)),rep(n.graphics, size%%n.graphics))
  }

  div.n.graphics <- div.n.graphics[1:n.ind]
  div.n.graphics <- rep(div.n.graphics, each = 2*length(unique(counts$LG)))

  counts$individual <- factor(as.character(counts$individual), levels = sort(as.character(unique(counts$individual))))
  counts$LG <- as.factor(counts$LG)
  if(any(colnames(counts) == "ploidy")) counts$ploidy <- as.factor(counts$ploidy)

  if(any(colnames(counts) == "ploidy")) ploidycolors <- brewer.pal(9, "Set1")[1:length(unique(counts$ploidy))]
  mycolors <- colorRampPalette(brewer.pal(12, "Paired"))(length(unique(counts$LG)))
  set.seed(20)
  mycolors <- sample(mycolors)
  if(any(colnames(counts) == "ploidy")) ploidycolors <- sample(ploidycolors)
  if(any(colnames(counts) == "ploidy")) names(ploidycolors) <- levels(counts$ploidy)
  names(mycolors) <- levels(counts$LG)

  p_list <- counts %>% ungroup() %>%  mutate(div.n.graphics = div.n.graphics) %>%
    split(., .$div.n.graphics) %>%
    lapply(., function(x) ggplot(x, aes(x=.data$parent, y=.data$total_counts, fill = .data$LG)) +
             {if(by_LG) geom_bar(stat = "identity", aes(fill = .data$LG)) else if(any(colnames(counts) == "ploidy")) geom_bar(stat = "identity", aes(fill = .data$ploidy)) else geom_bar(stat = "identity")}+
             coord_flip() +
             {if(by_LG) scale_fill_manual(values=mycolors) else if(any(colnames(counts) == "ploidy")) scale_fill_manual(values=ploidycolors)} +
             theme(axis.title.y = element_blank(),
                   axis.title.x = element_blank(),
                   axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
                   legend.key.size = unit(1, 'cm'),
                   strip.text.y.right = element_text(angle = 0)) +
             {if(!by_LG) facet_grid(.data$individual ~ .data$LG) else facet_grid(.data$individual ~ .)} +
             {if(by_LG) labs(fill="groups") else if(any(colnames(counts) == "ploidy")) labs(fill="ploidy")})

  p <- ggarrange(plotlist = p_list, common.legend = T, ncol = ncol, nrow = round(n.graphics/ncol,0))

  return(p)
}


#' Plots mappoly.homoprob from MAPpoly
#'
#' @param x an object of class \code{mappoly.homoprob}
#'
#' @param stack logical. If \code{TRUE}, probability profiles of all homologues
#'              are stacked in the plot (default = FALSE)
#'
#' @param lg indicates which linkage group should be plotted. If \code{NULL}
#'           (default), it plots the first linkage group. If
#'           \code{"all"}, it plots all linkage groups
#'
#' @param ind indicates which individuals should be plotted. It can be the
#'            position of the individuals in the dataset or it's name.
#'            If \code{NULL} (default), the function plots the first
#'            individual
#'
#' @param verbose if \code{TRUE} (default), the current progress is shown; if
#'     \code{FALSE}, no output is produced
#'
#' @param ... unused arguments
#'
#' @import ggplot2
#' @method plot mappoly.homoprob
#'
#' @export
plot.mappoly.homoprob <- function(x, stack = FALSE, lg = NULL,
                                  ind = NULL,
                                  verbose = TRUE, ...){

  all.ind <- as.character(unique(x$homoprob$individual))
  #### Individual handling ####
  if(length(ind) > 1){
    if (verbose) message("More than one individual provided: using the first one")
    ind <- ind[1]
  }
  if(is.null(ind)){
    ind <- as.character(all.ind[1])
    df.pr1 <- subset(x$homoprob, individual  ==  ind)
  } else if(is.numeric(ind)) {
    if(ind > length(all.ind))
      stop("Please chose an individual number between 1 and ", length(all.ind))
    ind <- as.character(all.ind[ind])
    df.pr1 <- subset(x$homoprob, individual  ==  ind)
  } else if (is.character(ind)){
    if(!ind%in%all.ind)
      stop("Invalid individual name")
  } else stop("Invalid individual name")

  #### LG handling ####
  if(is.null(lg))
    lg <- 1
  if(all(lg == "all"))
    lg <- unique(x$homoprob$LG)
  LG <- individual <- map.position <- probability <- homolog <- NULL
  if(length(lg) > 1 & !stack)
  {
    if (verbose) message("Using 'stack = TRUE' to plot multiple linkage groups")
    stack <- TRUE
  }
  if(stack){
    ##subset linkage group
    if(!is.null(lg)){
      df.pr1 <- subset(x$homoprob, LG%in%lg)
      df.pr1 <- subset(df.pr1, individual  ==  ind)
    } else
      df.pr1 <- subset(x$homoprob, individual  ==  ind)
    p <- ggplot(df.pr1, aes(x = map.position, y = probability, fill = homolog, color  = homolog)) +
      geom_density(stat = "identity", alpha = 0.7, position = "stack") +
      ggtitle(ind) +
      facet_grid(rows = vars(LG)) +
      ylab(label = "Homologs probabilty") +
      xlab(label = "Map position") +  theme_minimal()
  } else {
    ##subset linkage group
    if(is.null(lg)){
      lg <- 1
      df.pr1 <- subset(x$homoprob, LG %in% lg)
    } else df.pr1 <- subset(x$homoprob, LG %in% lg)
    df.pr1 <- subset(df.pr1, individual  ==  ind)
    p <- ggplot(df.pr1, aes(x = map.position, y = probability, fill = homolog, color  = homolog)) +
      geom_density(stat = "identity", alpha = 0.7) +
      ggtitle(paste(ind, "   LG", lg)) +
      facet_grid(rows = vars(homolog)) +
      theme_minimal() +
      ylab(label = "Homologs probabilty") +
      xlab(label = "Map position")
  }
  return(p)
}

#' Extracts genotype probabilities information from polyOrigin polyancentry output file
#' Code adapted from diaQTL
#'
#' @param filename character with path to polyancentry CSV file
#' @param outstem output pedigree filename
#'
#' @importFrom utils write.csv
#'
#' @export
read_polyOrigin <- function(filename, outstem=NULL){
  con <- file(filename,"r")
  temp <- readLines(con)
  ix <- grep("PolyOrigin",temp)

  k <- grep("offspringinfo",temp[ix])
  x <- strsplit(temp[c((ix[k]+2):(ix[k+1]-1))],split=",")
  ped <- data.frame(id=sapply(x,function(x){x[1]}),pop=sapply(x,function(x){x[2]}),stringsAsFactors = F)

  k <- grep("ancestralgenotype",temp[ix])
  x <- strsplit(temp[c((ix[k]+2):(ix[k+1]-1))],split=",")
  parents <- apply(cbind(sapply(x,function(x){x[1]}),sapply(x,function(x){x[3]})),1,paste,collapse="|")
  parents <- unique(parents)
  y <- strsplit(parents,split="|",fixed=T)
  parents <- data.frame(pop=sapply(y,function(y){y[1]}),parent1=sapply(y,function(y){y[2]}),parent2=sapply(y,function(y){y[length(y)]}),stringsAsFactors = F)
  ped <- merge(ped,parents)
  write.csv(ped[,2:4],file=paste(outstem,"diaQTL_pedfile.csv",sep=""),row.names=F)

  k <- grep("parentgeno",temp[ix])
  header <- setdiff(strsplit(temp[ix[k]+1],split=",",fixed=T)[[1]],"")
  parents <- header[-(1:3)]
  header[1:3] <- c("marker","chrom","cM")
  x <- strsplit(temp[c((ix[k]+2):(ix[k+1]-1))],split=",")
  m <- length(x)
  pp <- matrix("",nrow=m,ncol=length(header))
  for (i in 1:3) {
    pp[,i] <- sapply(x,function(z){z[i]})
  }
  for (i in 4:length(header)) {
    v <- sapply(x,function(z){z[i]})
    v <- gsub("1","0",v)
    pp[,i] <- gsub("2","1",v)
  }
  colnames(pp) <- header

  k <- grep("genoprob",temp[ix])
  id <- temp[ix[k]+1]
  id <- strsplit(id,split=",",fixed=T)[[1]][-(1:3)]
  keep <- 1:length(id)
  n <- length(keep)
  genoprob <- matrix("",nrow=m,ncol=n+1)
  colnames(genoprob) <- c("marker",id[keep])
  for (j in 1:m) {
    i <- ix[k]+1+j
    x <- strsplit(temp[i],split=",",fixed=T)[[1]]
    genoprob[j,] <- x[c(1,keep+3)]
  }
  df <- cbind(pp[,1:3],genoprob[match(pp[,1],genoprob[,1]),-1])
  close(con)
  return(df)
}

#' Converts polyOrigin genotype probabilities format to mappoly homoprob format
#'
#' @param df data.frame resulted from read_polyOrigin function
#' @param f1.codes data.frame with polyOrigin stages codification
#' @param ind character defining the individual to be evalueated
#' @param ploidy integer defining the ploidy
#' @param n.cores define how many cores to be used in parallelization
#'
#' @importFrom tidyr pivot_longer
#' @import parallel
#' @export
get_probs_polyorigin <- function(df, f1.codes, ind = NULL, ploidy = 4, n.cores= 1){
  df_prob <- data.frame(df)
  if(!is.null(ind)) df_prob <- df_prob[,c(1:3,which(colnames(df_prob) %in% ind))]
  melt_df <- pivot_longer(df_prob, cols = 4:ncol(df_prob), names_to = "ind", values_to = "geno")

  melt_df_lst <- split(melt_df, melt_df$ind)

  clust <- makeCluster(n.cores)
  homoprob.lst <- parLapply(clust, melt_df_lst, function(x) get_probs_sing(melt_df = x,
                                                                           f1.codes = f1.codes,
                                                                           ploidy = ploidy))
  stopCluster(clust)

  homoprob <- do.call(rbind, homoprob.lst)

  structure(list(info = list(ploidy = ploidy,
                             n.ind = length(unique(homoprob$individual))) ,
                 homoprob = homoprob), class = "mappoly.homoprob")
}

get_probs_polyorigin_sd <- function(df, f1.codes, ind = NULL, ploidy = 4, n.cores= 1){
  df_prob <- data.frame(df)
  if(!is.null(ind)) df_prob <- df_prob[,c(1:3,which(colnames(df_prob) %in% ind))]
  melt_df <- pivot_longer(df_prob, cols = 4:ncol(df_prob), names_to = "ind", values_to = "geno")

  melt_df_lst <- split(melt_df, melt_df$ind)

  clust <- makeCluster(n.cores)
  clusterExport(clust, c("f1.codes"))
  homoprob.lst <- parLapply(clust, melt_df_lst, function(x) Qploidy::get_probs_sing(melt_df = x,
                                                                                    f1.codes = f1.codes,
                                                                                    ploidy = ploidy))
  stopCluster(clust)

  homoprob <- do.call(rbind, homoprob.lst)

  structure(list(info = list(ploidy = ploidy,
                             n.ind = length(unique(homoprob$individual))) ,
                 homoprob = homoprob), class = "mappoly.homoprob")
}


#' Converts polyOrigin genotype probabilities format to mappoly homoprob format for a single individual
#'
#' @param melt_df long format of the data.frame resulted from read_polyOrigin function
#' @param f1.codes data.frame with polyOrigin stages codification
#' @param ploidy integer defining the ploidy
#'
#' @importFrom tidyr pivot_longer
#'
#' @export
get_probs_sing <- function(melt_df, f1.codes, ploidy){
  df_sep <- strsplit(melt_df$geno, "=>")
  states <- sapply(df_sep, "[[", 1)
  states <- strsplit(states, "[|]")
  states <- lapply(states, function(x) f1.codes$State[match(x, f1.codes$Code)])
  probs <- sapply(df_sep, "[[", 2)
  probs <- strsplit(probs, "[|]")
  probs <- lapply(probs, function(x) as.numeric(x)/sum(as.numeric(x)))
  #probs <- lapply(probs, function(x) as.numeric(x))

  p.probs <- list()
  for(i in 1:(2*ploidy)){
    p.probs[[i]] <- mapply(function(states, probs){
      sum(probs[grep(i, states)])
    }, states, probs)
  }

  # Detect double reduction
  p.probs <- do.call(cbind,p.probs)
  p.probs[,1:ploidy] <- t(apply(p.probs[,1:ploidy], 1, function(x) (2*x)/sum(x)))
  p.probs[,(ploidy+1):(2*ploidy)] <- t(apply(p.probs[,(ploidy+1):(2*ploidy)], 1, function(x) (2*x)/sum(x)))


  colnames(p.probs) <- letters[1:(ploidy*2)]

  df_all <- cbind(melt_df[,-ncol(melt_df)],p.probs)
  homoprob <- pivot_longer(df_all, cols = 5:ncol(df_all), names_to = "homolog", values_to = "probability")
  homoprob <- data.frame(marker = homoprob$marker, homolog = homoprob$homolog,
                         individual = homoprob$ind, probability = homoprob$probability,
                         map.position = as.numeric(homoprob$cM), LG = homoprob$chrom)
  print(paste0("Individual ", unique(homoprob$ind), " done!"))
  return(homoprob)
}