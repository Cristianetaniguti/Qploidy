---
title: "Code version"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Packages

```{r}
library(vroom)
library(fitPoly)
library(Qploidy)
library(tidyr)
library(dplyr)
```



## Interpolation

```{r}
# Roses texas
summary <- vroom("summary_roses_texas.txt")
cleaned_summary <- clean_summary(summary_df = summary)

ind.names <- vroom("ind.names_roses_texas.txt")

R_theta <- get_R_theta(cleaned_summary, ind.names, sd.normalization = FALSE)

R_all <- R_theta[[1]]
theta_all <- R_theta[[2]]

fitpoly_input <- summary_to_fitpoly(R_all, theta_all)

refs <- vroom("tetraploid_refs_roses_texas.txt", delim = "\t")
refs$sample_name

fitpoly_input_sele <- fitpoly_input[which(fitpoly_input$SampleName %in% refs$sample_name),]

saveMarkerModels(ploidy=4,
                 data=fitpoly_input_sele,
                 p.threshold=0.9,
                 filePrefix="fitpoly_out_roses_texas2",
                 ncores=20)


scores <- vroom("fitpoly_out_roses_texas_scores.dat")

n.na <- scores %>% group_by(MarkerName) %>% summarize(n.na = (sum(is.na(geno))/length(geno))*100)

rm.mks <- n.na$MarkerName[which(n.na$n.na > 25)]
missing.data <- length(rm.mks)
scores_filt <- scores[-which(scores$MarkerName %in% rm.mks),]

keep.mks <- which(fitpoly_input$MarkerName %in% scores_filt$MarkerName & fitpoly_input$SampleName %in% scores_filt$SampleName)

fitpoly_input_filt <- fitpoly_input[keep.mks,]
theta <- fitpoly_input_filt$ratio
R <- fitpoly_input_filt$R

rm.na <- which(is.na(scores_filt$geno))
if(length(rm.na) > 0){
  R[rm.na] <- NA
  theta[rm.na] <- NA
}


data_interpolation <- data.frame(mks = fitpoly_input_filt$MarkerName,
                                 ind = fitpoly_input_filt$SampleName,
                                 R = R,
                                 theta = theta,
                                 geno = scores_filt$geno)

lst_interpolation <- split(data_interpolation, data_interpolation$mks)

# Generate clusters
library(parallel)
ploidy <- 4
clust <- makeCluster(20)
clusterExport(clust, c("par_fitpoly_interpolation", "ploidy"))
clusters <- parLapply(clust, lst_interpolation, function(x) {
  library(ggplot2)
  par_fitpoly_interpolation(x, ploidy= ploidy, plot = FALSE)
})
stopCluster(clust)

# Filter by number of clusters
rm.mks <- sapply(clusters, function(x) is.null(x$mod))
wrong_n_clusters <- sum(rm.mks)
clusters_filt <- clusters[-which(rm.mks)]

# Filtered markers table
filtered.markers <- data.frame(nrow(R_all),
                               missing.data,
                               wrong_n_clusters,
                               length(clusters_filt))

colnames(filtered.markers) <- c("n.mk.start", "missing.data", "wrong_n_clusters", "n.mk.selected")


mks <- names(clusters)
mks[which(rm.mks)] <- paste(mks[which(rm.mks)], "(discarded)")
# Plot markers interpolation
p <- plot_one_marker(lst_interpolation[[1]], ploidy = 4)
p

keep.mks <- names(clusters_filt)
# Getting logR and BAF for entire dataset
R_filt <- R_all[match(keep.mks, R_all$MarkerName),]
theta_filt <- theta_all[match(keep.mks, theta_all$MarkerName),]

n.cores <- 20
par <- rep(1:n.cores, each=round((nrow(R_filt)/n.cores)+1,0))[1:nrow(R_filt)]

par_R <- split.data.frame(R_filt[,-1], par)
par_theta <- split.data.frame(theta_filt[,-1], par)
par_clusters_filt <- split(clusters_filt, par)

par_all <- list()
for(i in 1:n.cores){
  par_all[[i]] <- list()
  par_all[[i]][[1]] <- par_R[[i]]
  par_all[[i]][[2]] <- par_theta[[i]]
  par_all[[i]][[3]] <- par_clusters_filt[[i]]
}

clust <- makeCluster(n.cores)
clusterExport(clust, c("get_logR", "get_logR_par", "ploidy"))
logRs_diplo <- parLapply(clust, par_all, function(x) {
  get_logR_par(x, ploidy = ploidy)
})
stopCluster(clust)

logRs_diplod_lt <- unlist(logRs_diplo, recursive = F)
logRs_diplod_m <- do.call(rbind, logRs_diplod_lt)
rownames(logRs_diplod_m) <- keep.mks
logRs_diplod_m <- cbind(mks=rownames(logRs_diplod_m), logRs_diplod_m)

# Get BAF
clust <- makeCluster(n.cores)
clusterExport(clust, c("get_baf", "get_baf_par", "ploidy"))
bafs_diplo <- parLapply(clust, par_all, function(x) {
  get_baf_par(x, ploidy = ploidy)
})
stopCluster(clust)

bafs_diplo_lt <- unlist(bafs_diplo, recursive = F)
bafs_diplo_m <- do.call(rbind, bafs_diplo_lt)
rownames(bafs_diplo_m) <- keep.mks
colnames(bafs_diplo_m) <- colnames(logRs_diplod_m)[-1]
bafs_diplo_df <- as.data.frame(bafs_diplo_m)
bafs_diplo_df <- cbind(mks=rownames(bafs_diplo_df), bafs_diplo_df)

# Add chr and pos info
geno.pos <- vroom("geno.pos_roses_texas2.txt")

chr <- geno.pos$chr[match(bafs_diplo_df$mks,geno.pos$probes)]
pos <- geno.pos$pos[match(bafs_diplo_df$mks,geno.pos$probes)]

baf <- cbind(Name=bafs_diplo_df$mks, Chr = chr, Position = pos, bafs_diplo_df[,-1])
logR <- cbind(Name=logRs_diplod_m$mks, Chr = chr, Position = pos, logRs_diplod_m[,-1])

sum(is.nan(as.matrix(logR[,-c(1:3)])))

baf <- baf[-which(is.na(baf$Chr) | baf$Chr == "0"),]
logR <- logR[-which(is.na(logR$Chr)| logR$Chr == "0"),]

vroom_write(baf, file = "baf_roses_texas.txt")
vroom_write(logR, file = "logR_roses_texas.txt")

```



