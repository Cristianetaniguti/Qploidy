---
title: "Code version"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Packages

```{r}
library(vroom)
library(fitPoly)
library(Qploidy)
library(tidyr)
library(dplyr)
```

# Roses Texas

## Interpolation

```{r}
# Roses texas
summary <- vroom("summary_roses_texas.txt")
cleaned_summary <- clean_summary(summary_df = summary)

ind.names <- vroom("ind.names_roses_texas.txt")

R_theta <- get_R_theta(cleaned_summary, ind.names, sd.normalization = FALSE)

R_all <- R_theta[[1]]
theta_all <- R_theta[[2]]

fitpoly_input <- summary_to_fitpoly(R_all, theta_all)

refs <- vroom("fitpoly/tetraploid_refs_roses_texas.txt", delim = "\t")
refs$sample_name

fitpoly_input_sele <- fitpoly_input[which(fitpoly_input$SampleName %in% refs$sample_name),]

saveMarkerModels(ploidy=4,
                 data=fitpoly_input_sele,
                 p.threshold=0.9,
                 filePrefix="fitpoly_out_roses_texas2",
                 ncores=20)


scores <- vroom("fitpoly/fitpoly_out_roses_texas_scores.dat")

n.na <- scores %>% group_by(MarkerName) %>% summarize(n.na = (sum(is.na(geno))/length(geno))*100)

rm.mks <- n.na$MarkerName[which(n.na$n.na > 25)]
missing.data <- length(rm.mks)
scores_filt <- scores[-which(scores$MarkerName %in% rm.mks),]

keep.mks <- which(fitpoly_input$MarkerName %in% scores_filt$MarkerName & fitpoly_input$SampleName %in% scores_filt$SampleName)

fitpoly_input_filt <- fitpoly_input[keep.mks,]
theta <- fitpoly_input_filt$ratio
R <- fitpoly_input_filt$R

rm.na <- which(is.na(scores_filt$geno))
if(length(rm.na) > 0){
  R[rm.na] <- NA
  theta[rm.na] <- NA
}

data_interpolation <- data.frame(mks = fitpoly_input_filt$MarkerName,
                                 ind = fitpoly_input_filt$SampleName,
                                 R = R,
                                 theta = theta,
                                 geno = scores_filt$geno)

lst_interpolation <- split(data_interpolation, data_interpolation$mks)

# Generate clusters
library(parallel)
ploidy <- 4
clust <- makeCluster(20)
clusterExport(clust, c("par_fitpoly_interpolation", "ploidy"))
clusters <- parLapply(clust, lst_interpolation, function(x) {
  library(ggplot2)
  par_fitpoly_interpolation(x, ploidy= ploidy, plot = FALSE)
})
stopCluster(clust)

# Filter by number of clusters
rm.mks <- sapply(clusters, function(x) is.null(x$mod))
wrong_n_clusters <- sum(rm.mks)
clusters_filt <- clusters[-which(rm.mks)]

# Filtered markers table
filtered.markers <- data.frame(nrow(R_all),
                               missing.data,
                               wrong_n_clusters,
                               length(clusters_filt))

colnames(filtered.markers) <- c("n.mk.start", "missing.data", "wrong_n_clusters", "n.mk.selected")


mks <- names(clusters)
mks[which(rm.mks)] <- paste(mks[which(rm.mks)], "(discarded)")
# Plot markers interpolation
p <- plot_one_marker(lst_interpolation[[1]], ploidy = 4)
p

keep.mks <- names(clusters_filt)
# Getting logR and BAF for entire dataset
R_filt <- R_all[match(keep.mks, R_all$MarkerName),]
theta_filt <- theta_all[match(keep.mks, theta_all$MarkerName),]

n.cores <- 20
par <- rep(1:n.cores, each=round((nrow(R_filt)/n.cores)+1,0))[1:nrow(R_filt)]

par_R <- split.data.frame(R_filt[,-1], par)
par_theta <- split.data.frame(theta_filt[,-1], par)
par_clusters_filt <- split(clusters_filt, par)

par_all <- list()
for(i in 1:n.cores){
  par_all[[i]] <- list()
  par_all[[i]][[1]] <- par_R[[i]]
  par_all[[i]][[2]] <- par_theta[[i]]
  par_all[[i]][[3]] <- par_clusters_filt[[i]]
}

clust <- makeCluster(n.cores)
clusterExport(clust, c("get_logR", "get_logR_par", "ploidy"))
logRs_diplo <- parLapply(clust, par_all, function(x) {
  get_logR_par(x, ploidy = ploidy)
})
stopCluster(clust)

logRs_diplod_lt <- unlist(logRs_diplo, recursive = F)
logRs_diplod_m <- do.call(rbind, logRs_diplod_lt)
rownames(logRs_diplod_m) <- keep.mks
logRs_diplod_m <- cbind(mks=rownames(logRs_diplod_m), logRs_diplod_m)

# Get BAF
clust <- makeCluster(n.cores)
clusterExport(clust, c("get_baf", "get_baf_par", "ploidy"))
bafs_diplo <- parLapply(clust, par_all, function(x) {
  get_baf_par(x, ploidy = ploidy)
})
stopCluster(clust)

bafs_diplo_lt <- unlist(bafs_diplo, recursive = F)
bafs_diplo_m <- do.call(rbind, bafs_diplo_lt)
rownames(bafs_diplo_m) <- keep.mks
colnames(bafs_diplo_m) <- colnames(logRs_diplod_m)[-1]
bafs_diplo_df <- as.data.frame(bafs_diplo_m)
bafs_diplo_df <- cbind(mks=rownames(bafs_diplo_df), bafs_diplo_df)

# Add chr and pos info
geno.pos <- vroom("geno.pos_roses_texas2.txt")

chr <- geno.pos$chr[match(bafs_diplo_df$mks,geno.pos$probes)]
pos <- geno.pos$pos[match(bafs_diplo_df$mks,geno.pos$probes)]

baf <- cbind(Name=bafs_diplo_df$mks, Chr = chr, Position = pos, bafs_diplo_df[,-1])
logR <- cbind(Name=logRs_diplod_m$mks, Chr = chr, Position = pos, logRs_diplod_m[,-1])

sum(is.nan(as.matrix(logR[,-c(1:3)])))

baf <- baf[-which(is.na(baf$Chr) | baf$Chr == "0"),]
logR <- logR[-which(is.na(logR$Chr)| logR$Chr == "0"),]

vroom_write(baf, file = "baf_roses_texas.txt")
vroom_write(logR, file = "logR_roses_texas.txt")
```


## Overal analysis

```{r}
#inputs
input <- list()
#input$samples <- c("Diplo_1", "Diplo_2","Tetra_1","Tetra_2","Unknow_1")
input$ploidys <- c(2,6)
input$area <- 0.75
input$filter_corr <- 0
input$filter_diff <- 0.1
input$graphics <- c("Unknow_1")
input$area_single <- 0.75
input$dot.size <- 1
input$colors <- TRUE
input$add_lines <- TRUE
input$ploidy <- 4

# upload files
baf <- vroom("C:/Users/Rose_Lab/Documents/Cris_temp/Qploidy_data/roses_texas/fitpoly/baf_roses_texas.txt", show_col_types = FALSE)
logR <- vroom("C:/Users/Rose_Lab/Documents/Cris_temp/Qploidy_data/roses_texas/fitpoly/logR_roses_texas.txt", show_col_types = FALSE)

logR_baf <- list(logR, baf)

# Get overall ploidy estimation tables
#data_sample <- logR_baf[[2]][,c(2,3,which(colnames(logR_baf[[2]]) %in% c(input$samples)))]
data_sample <- logR_baf[[2]][,-1]

data_sample <- data_sample[order(data_sample$Chr, data_sample$Position),]

est.ploidy.chr_df <- area_estimate_ploidy_by_chr(data_sample, ploidys = input$ploidys, area = input$area)

saveRDS(est.ploidy.chr_df,  file = "ploidy.data.frames_2-6.rds")

# Get overall ploidy estimation graphics
## Aneuploid individuals
ps <- plots_overall(est.ploidy.chr_df,
                    filter_diff = input$filter_diff,
                    filter_corr = input$filter_corr)

# Overal break counts
## Load curated data
aneuploids <- read.csv("C:/Users/Rose_Lab/Documents/Cris_temp/Qploidy_data/roses_texas/Qploidy_all_curated.csv")

aneuploids <- aneuploids[,-9]
colnames(aneuploids)[1] <- "X"

# aneuploids <- as.data.frame(est.ploidy.chr_df[[1]])
# aneuploids <- data.frame(X=rownames(est.ploidy.chr_df[[1]]), est.ploidy.chr_df[[1]])

haplo_mappoly <- readRDS("C:/Users/Rose_Lab/Documents/Cris_temp/TAMU-RoseLab/standalone_apps/ploidy_estimation/data/count_breaks_poly/homoprob_normal.RDS")

genoprob <- read_polyOrigin(filename = "C:/Users/Rose_Lab/Documents/Cris_temp/Qploidy_data/roses_texas/5pop_compareprob2_fulldata_polyancestry.csv")

f1.codes <- vroom(system.file("F1codes.polyorigin.txt", package = "Qploidy"), show_col_types = FALSE)
haplo_polyorigin <- Qploidy:::get_probs_polyorigin_sd(genoprob,
                                                      f1.codes = f1.codes,
                                                      ploidy = 4, n.cores = 20)

#saveRDS(haplo_polyorigin, file = "haplo_polyorigin_rose_texas.rds", compress = TRUE)
haplo_polyorigin <- readRDS("haplo_polyorigin_rose_texas.rds")
haplo_polyorigin$homoprob$individual <- gsub("^X", "", haplo_polyorigin$homoprob$individual)

library(diaQTL)

convert_polyorigin("C:/Users/Rose_Lab/Documents/Cris_temp/Qploidy_data/roses_texas/5pop_compareprob2_fulldata_polyancestry.csv")

data <- read_data(genofile = "diaQTL_genofile.csv",
                  ploidy = 4,
                  pedfile = "diaQTL_pedfile.csv",
                  n.core = 2)

p_d <- haplo_plot(data = data,
                id = "16401_N025",
                chrom = 2,
                position = "cM")

plot(haplo_polyorigin, lg = 6, ind = "16035_N034")

p_p_df %>% filter(individual == "16035_N034")

## MAPpoly

# fix sample names
haplo_mappoly$homoprob$individual <- gsub("^X", "", haplo_mappoly$homoprob$individual)

p_m_df <- count_breaks_df(homoprob = haplo_mappoly$homoprob,
                          aneuploids = aneuploids)

vroom_write(p_m_df, file = "mappoly_break_counts.txt")

#p_m_df <- vroom("mappoly_break_counts.txt")

end <- c(seq(20,140, 20), 161) 
start <- seq(1,141, 20)

p_m_plot <- list()
for(i in 1:length(end)){
  temp <- p_m_df[which(p_m_df$individual %in% unique(p_m_df$individual)[start[i]:end[i]]),]
  p_m_plot[[i]] <- count_breaks_plot(temp, by_LG = FALSE)
  ggsave(p_m_plot[[i]], file= paste0("p_mappoly_counts_", i, ".png"), height = 8, width = 5)
}

## polyOrigin

# fix sample names
haplo_polyorigin$homoprob$individual <- gsub("^X", "", haplo_polyorigin$homoprob$individual)

p_p_df <- count_breaks_df(homoprob = haplo_polyorigin$homoprob,
                          aneuploids = aneuploids,
                          ped.file = "diaQTL_pedfile.csv")

vroom_write(counts, file = "polyorigin_break_counts_up_parents.txt")

p_p_df <- vroom("polyorigin_break_counts_up_parents.txt")
p_p_plot_pop <- list()
pops <- c("MBxGV", "MBxRR", "MBxBE", "16009", 
          "16035", "16009", "16400", "16401",
          "16405")

for(i in 1:length(pops)){
  p_p_plot_pop <- p_p_df[grep(pops[i], p_p_df$individual),]
  end <- c(seq(20,length(unique(p_p_plot_pop$individual)), 20), length(unique(p_p_plot_pop$individual))) 
  start <- seq(1,length(unique(p_p_plot_pop$individual)), 20)
  for(j in 1:length(end)){
    temp <- p_p_plot_pop[which(p_p_plot_pop$individual %in% unique(p_p_plot_pop$individual)[start[j]:end[j]]),]
    p_p_plot <- count_breaks_plot(temp, by_LG = FALSE)
    ggsave(p_p_plot, file= paste0("p_polyorigin_counts_", pops[i],"_", j,".png"), height = 8, width = 5)
  }
}


```

## Compare present with curated ploidy

```{r}
curated <- read.csv("curated_ploidies.csv")
colnames(curated)[1] <- "ID"

ploidies1_7 <- readRDS("fitpoly/ploidy.data.frames_1-7.rds")
ploidies1_7 <- ploidies1_7[[1]]
ploidies2_5 <- readRDS("fitpoly/ploidy.data.frames_2-5.rds")
qual <- ploidies2_5[[3]]
ploidies2_5 <- ploidies2_5[[1]]

rownames(ploidies1_7)[which(!(rownames(ploidies1_7) %in% curated$ID))]

comp1_7 <- ploidies1_7[match(curated$ID, rownames(ploidies1_7)),]
comp2_5 <- ploidies2_5[match(curated$ID, rownames(ploidies2_5)),]

dim(comp1_7)
dim(comp2_5)

sum(comp1_7 == comp2_5)/length(comp2_5) # 96.63%
sum(curated[,-1] == comp1_7, na.rm = TRUE)/length(comp1_7) # 93.74%
sum(curated[,-1] == comp2_5, na.rm = TRUE)/length(comp2_5) # 94.11% 

# Curating

check_sample1 <- which(curated[,-1] != comp2_5, arr.ind = TRUE)
check_sample1 <- unique(check_sample1[,1])
length(check_sample1) # Check 158 samples


check_sample2 <- which(curated[,-1] != comp1_7, arr.ind = TRUE)
check_sample2 <- unique(check_sample2[,1])
length(check_sample2) # Check 170 samples

changed <- curated[check_sample2,1]


check_sample1 %in% check_sample2

# being more restrictive:
write.csv(curated[check_sample2,], file = "old_method_diff.csv")
write.csv(comp1_7[check_sample2,], file = "1_7_method_diff.csv")
write.csv(comp2_5[check_sample2,], file = "2_5_method_diff.csv")


# Tetraploids

ind <- vroom("temp.txt", "\n", col_names = F)
ind <- as.vector(ind$X1)

ploidies2_5[which(qual < 0.01)] <- NA

sum(qual < 0.01)/length(qual)

new_all <- ploidies2_5[match(ind, rownames(ploidies2_5)),]
new_all_changes <- cbind(new_all, NA)
new_all_changes[match(changed, rownames(new_all_changes)),8] <- "changed"
write.csv(new_all_changes, file = "new_all_changed.csv")

```

# Potato Texas

```{r}
raw <- vroom("data/potato/Texas_A_M_Vales_PLTPOTV04_20211115_FinalReport.txt", delim = "\t", skip = 9)
raw1 <- raw[,c(1,2,7,8)]

raw1$`Sample ID` <- paste0(raw1$`Sample ID`, "_0")

raw <- vroom("data/potato/TAMU_Potato_SNP_Set1.txt", delim = "\t", skip = 9)
raw1.1 <- raw[,c(1,2,5,6)]

raw1.1$`Sample ID` <- paste0(raw1.1$`Sample ID`, "_1")

raw1 <- rbind(raw1, raw1.1)

raw <- vroom("data/potato/TAMU_Potato_SNP_Set2.txt", delim = "\t", skip = 9)
raw1.1 <- raw[,c(1,2,7,8)]

raw1.1$`Sample ID` <- paste0(raw1.1$`Sample ID`, "_2")

raw1 <- rbind(raw1, raw1.1)

raw <- vroom("data/potato/TAMU_Potato_SNP_Set3.txt", delim = "\t", skip = 9)
raw1.1 <- raw[,c(1,2,7,8)]

raw1.1$`Sample ID` <- paste0(raw1.1$`Sample ID`, "_3")

raw1 <- rbind(raw1, raw1.1)

raw <- vroom("data/potato/TAMU_Potato_SNP_Set4.txt", delim = "\t", skip = 9)
raw1.1 <- raw[,c(1,2,7,8)]

raw1.1$`Sample ID` <- paste0(raw1.1$`Sample ID`, "_4")

raw1 <- rbind(raw1, raw1.1)

fitpoly_potato_input <- cbind(raw1, R = raw1$X + raw1$Y, ratio = raw1$Y/(raw1$X + raw1$Y))

saveRDS(fitpoly_potato_input, file = "fitpoly_potato_input.rds")

```

```{r}
library(vroom)
library(dplyr)
library(tidyr)

fitpoly_potato_input <- readRDS("data/potato/fitpoly_potato_input.rds")
scores <- vroom("data/potato/tetraploids_refs_potato_scores.dat")

n.na <- scores %>% group_by(MarkerName) %>% summarize(n.na = (sum(is.na(geno))/length(geno))*100)

rm.mks <- n.na$MarkerName[which(n.na$n.na > 25)]
missing.data <- length(rm.mks)
scores_filt <- scores[-which(scores$MarkerName %in% rm.mks),]

# keep.mks <- which(fitpoly_potato_input$MarkerName %in% scores_filt$MarkerName & fitpoly_potato_input$SampleName %in% scores_filt$SampleName)

keep.mks <- match(paste0(scores_filt$SampleName, "_", scores_filt$MarkerName),
                  paste0(fitpoly_potato_input$SampleName, "_", fitpoly_potato_input$MarkerName))

fitpoly_input_filt <- fitpoly_potato_input[keep.mks,]
theta <- fitpoly_input_filt$ratio
R <- fitpoly_input_filt$R

rm.na <- which(is.na(scores_filt$geno))
if(length(rm.na) > 0){
  R[rm.na] <- NA
  theta[rm.na] <- NA
}

data_interpolation <- data.frame(mks = fitpoly_input_filt$MarkerName,
                                 ind = fitpoly_input_filt$SampleName,
                                 R = R,
                                 theta = theta,
                                 geno = scores_filt$geno)

lst_interpolation <- split(data_interpolation, data_interpolation$mks)

# Generate clusters
library(parallel)
ploidy <- 4
clust <- makeCluster(20)
clusterExport(clust, c("par_fitpoly_interpolation", "ploidy"))
clusters <- parLapply(clust, lst_interpolation, function(x) {
  library(ggplot2)
  par_fitpoly_interpolation(x, ploidy= ploidy, plot = FALSE)
})
stopCluster(clust)

# Filter by number of clusters
rm.mks <- sapply(clusters, function(x) is.null(x$mod))
wrong_n_clusters <- sum(rm.mks)
clusters_filt <- clusters[-which(rm.mks)]

# Filtered markers table
filtered.markers <- data.frame(length(unique(fitpoly_potato_input$MarkerName)),
                               missing.data,
                               wrong_n_clusters,
                               length(clusters_filt))

colnames(filtered.markers) <- c("n.mk.start", "missing.data", "wrong_n_clusters", "n.mk.selected")


mks <- names(clusters)
mks[which(rm.mks)] <- paste(mks[which(rm.mks)], "(discarded)")
# Plot markers interpolation
p <- plot_one_marker(lst_interpolation[[6]], ploidy = 4)
p

keep.mks <- names(clusters_filt)
# Getting logR and BAF for entire dataset
R_filt <- pivot_wider(data_interpolation[which(data_interpolation$mks %in% keep.mks),-c(4,5)], names_from = "ind", values_from = "R")
theta_filt <- pivot_wider(data_interpolation[which(data_interpolation$mks %in% keep.mks),-c(3,5)], names_from = "ind", values_from = "theta")

n.cores <- 20
par <- rep(1:n.cores, each=round((nrow(R_filt)/n.cores)+1,0))[1:nrow(R_filt)]

par_R <- split.data.frame(R_filt[,-1], par)
par_theta <- split.data.frame(theta_filt[,-1], par)
par_clusters_filt <- split(clusters_filt, par)

par_all <- list()
for(i in 1:n.cores){
  par_all[[i]] <- list()
  par_all[[i]][[1]] <- par_R[[i]]
  par_all[[i]][[2]] <- par_theta[[i]]
  par_all[[i]][[3]] <- par_clusters_filt[[i]]
}

clust <- makeCluster(n.cores)
clusterExport(clust, c("get_logR", "get_logR_par", "ploidy"))
logRs_diplo <- parLapply(clust, par_all, function(x) {
  get_logR_par(x, ploidy = ploidy)
})
stopCluster(clust)

logRs_diplod_lt <- unlist(logRs_diplo, recursive = F)
logRs_diplod_m <- do.call(rbind, logRs_diplod_lt)
rownames(logRs_diplod_m) <- R_filt$mks
logRs_diplod_m <- cbind(mks=rownames(logRs_diplod_m), logRs_diplod_m)

# Get BAF
clust <- makeCluster(n.cores)
clusterExport(clust, c("get_baf", "get_baf_par", "ploidy"))
bafs_diplo <- parLapply(clust, par_all, function(x) {
  get_baf_par(x, ploidy = ploidy)
})
stopCluster(clust)

bafs_diplo_lt <- unlist(bafs_diplo, recursive = F)
bafs_diplo_m <- do.call(rbind, bafs_diplo_lt)
rownames(bafs_diplo_m) <- theta_filt$mks
colnames(bafs_diplo_m) <- colnames(logRs_diplod_m)[-1]
bafs_diplo_df <- as.data.frame(bafs_diplo_m)
bafs_diplo_df <- cbind(mks=rownames(bafs_diplo_df), bafs_diplo_df)

# Add chr and pos info
geno.pos <- vroom("data/potato/Potato_SNP_Map.txt")

chr <- geno.pos$Chromosome[match(bafs_diplo_df$mks,geno.pos$Name)]
pos <- geno.pos$Position[match(bafs_diplo_df$mks,geno.pos$Name)]

baf <- cbind(Name=bafs_diplo_df$mks, Chr = chr, Position = pos, bafs_diplo_df[,-1])
logR <- cbind(Name=logRs_diplod_m$mks, Chr = chr, Position = pos, logRs_diplod_m[,-1])

sum(is.nan(as.matrix(logR[,-c(1:3)])))

baf <- baf[-which(is.na(baf$Chr) | baf$Chr == "0"),]
logR <- logR[-which(is.na(logR$Chr)| logR$Chr == "0"),]

vroom_write(baf, file = "data/potato/baf_potato_texas2.txt")
vroom_write(logR, file = "data/potato/logR_potato_texas2.txt")


baf <- vroom("data/potato/baf_potato_texas.txt")
baf <- baf[,-4]
baf <- baf[-which(grepl("CHLOROPLAST", baf$Chr) | grepl("CH00", baf$Chr)),]

logR <- vroom("data/potato/logR_potato_texas.txt")
logR <- logR[,-4]
logR <- logR[-which(grepl("CHLOROPLAST", logR$Chr) | grepl("CH00", logR$Chr)),]
```


## Re-run interpolation

```{r}
library(vroom)
library(dplyr)
library(tidyr)

fitpoly_potato_input <- readRDS("C:/Users/Rose_Lab/Documents/Cris_temp/TAMU-RoseLab/standalone_apps/ploidy_estimation/data/potato/fitpoly_potato_input.rds")

# Filter - keep only tetraploids for clusterization with fitpoly
tetra <- vroom("C:/Users/Rose_Lab/Documents/Cris_temp/Qploidy_data/potato_texas/tetraploids", delim = "\n")

data <- fitpoly_potato_input %>% filter(SampleName %in% tetra$names)

saveMarkerModels(ploidy=4,
                 data=data,
                 p.threshold=0.9,
                 filePrefix="fitpoly_out_potato_texas2",
                 ncores=20)

```

```{r}
library(vroom)
library(dplyr)
library(tidyr)

fitpoly_potato_input <- readRDS("C:/Users/Rose_Lab/Documents/Cris_temp/TAMU-RoseLab/standalone_apps/ploidy_estimation/data/potato/fitpoly_potato_input.rds")
scores <- vroom("C:/Users/Rose_Lab/Documents/Cris_temp/Qploidy_data/potato_texas/fitpoly_out_potato_texas2_scores.dat")

n.na <- scores %>% group_by(MarkerName) %>% summarize(n.na = (sum(is.na(geno))/length(geno))*100)

rm.mks <- n.na$MarkerName[which(n.na$n.na > 25)]
missing.data <- length(rm.mks)
scores_filt <- scores[-which(scores$MarkerName %in% rm.mks),]

# keep.mks <- which(fitpoly_potato_input$MarkerName %in% scores_filt$MarkerName & fitpoly_potato_input$SampleName %in% scores_filt$SampleName)

keep.mks <- match(paste0(scores_filt$SampleName, "_", scores_filt$MarkerName),
                  paste0(fitpoly_potato_input$SampleName, "_", fitpoly_potato_input$MarkerName))

fitpoly_input_filt <- fitpoly_potato_input[keep.mks,]
theta <- fitpoly_input_filt$ratio
R <- fitpoly_input_filt$R

rm.na <- which(is.na(scores_filt$geno))
if(length(rm.na) > 0){
  R[rm.na] <- NA
  theta[rm.na] <- NA
}

data_interpolation <- data.frame(mks = fitpoly_input_filt$MarkerName,
                                 ind = fitpoly_input_filt$SampleName,
                                 R = R,
                                 theta = theta,
                                 geno = scores_filt$geno)

lst_interpolation <- split(data_interpolation, data_interpolation$mks)

# Generate clusters
library(parallel)
ploidy <- 4
clust <- makeCluster(20)
clusterExport(clust, c("par_fitpoly_interpolation", "ploidy"))
clusters <- parLapply(clust, lst_interpolation, function(x) {
  library(ggplot2)
  par_fitpoly_interpolation(x, ploidy= ploidy, plot = FALSE)
})
stopCluster(clust)

# Filter by number of clusters
rm.mks <- sapply(clusters, function(x) is.null(x$mod))
wrong_n_clusters <- sum(rm.mks)
clusters_filt <- clusters[-which(rm.mks)]

# Filtered markers table
filtered.markers <- data.frame(length(unique(fitpoly_potato_input$MarkerName)),
                               missing.data,
                               wrong_n_clusters,
                               length(clusters_filt))

colnames(filtered.markers) <- c("n.mk.start", "missing.data", "wrong_n_clusters", "n.mk.selected")


mks <- names(clusters)
mks[which(rm.mks)] <- paste(mks[which(rm.mks)], "(discarded)")
# Plot markers interpolation
p <- plot_one_marker(lst_interpolation[[4]], ploidy = 4)
p

keep.mks <- names(clusters_filt)
# Getting logR and BAF for entire dataset
R_filt <- pivot_wider(fitpoly_potato_input[which(fitpoly_potato_input$MarkerName %in% keep.mks),-c(3,4,6)], names_from = "SampleName", values_from = "R")
theta_filt <- pivot_wider(fitpoly_potato_input[which(fitpoly_potato_input$MarkerName %in% keep.mks),-c(3,4,5)], names_from = "SampleName", values_from = "ratio")

n.cores <- 20
par <- rep(1:n.cores, each=round((nrow(R_filt)/n.cores)+1,0))[1:nrow(R_filt)]

par_R <- split.data.frame(R_filt[,-1], par)
par_theta <- split.data.frame(theta_filt[,-1], par)
par_clusters_filt <- split(clusters_filt, par)

par_all <- list()
for(i in 1:n.cores){
  par_all[[i]] <- list()
  par_all[[i]][[1]] <- par_R[[i]]
  par_all[[i]][[2]] <- par_theta[[i]]
  par_all[[i]][[3]] <- par_clusters_filt[[i]]
}

clust <- makeCluster(n.cores)
clusterExport(clust, c("get_logR", "get_logR_par", "ploidy"))
logRs_diplo <- parLapply(clust, par_all, function(x) {
  get_logR_par(x, ploidy = ploidy)
})
stopCluster(clust)

logRs_diplod_lt <- unlist(logRs_diplo, recursive = F)
logRs_diplod_m <- do.call(rbind, logRs_diplod_lt)
rownames(logRs_diplod_m) <- R_filt$mks
logRs_diplod_m <- cbind(mks=rownames(logRs_diplod_m), logRs_diplod_m)

# Get BAF
clust <- makeCluster(n.cores)
clusterExport(clust, c("get_baf", "get_baf_par", "ploidy"))
bafs_diplo <- parLapply(clust, par_all, function(x) {
  get_baf_par(x, ploidy = ploidy)
})
stopCluster(clust)

bafs_diplo_lt <- unlist(bafs_diplo, recursive = F)
bafs_diplo_m <- do.call(rbind, bafs_diplo_lt)
rownames(bafs_diplo_m) <- theta_filt$MarkerName
colnames(bafs_diplo_m) <- colnames(logRs_diplod_m)[-1]
bafs_diplo_df <- as.data.frame(bafs_diplo_m)
bafs_diplo_df <- cbind(mks=rownames(bafs_diplo_df), bafs_diplo_df)

# Add chr and pos info
geno.pos <- vroom("C:/Users/Rose_Lab/Documents/Cris_temp/TAMU-RoseLab/standalone_apps/ploidy_estimation/data/potato/Potato_SNP_Map.txt")

chr <- geno.pos$Chromosome[match(bafs_diplo_df$mks,geno.pos$Name)]
pos <- geno.pos$Position[match(bafs_diplo_df$mks,geno.pos$Name)]

baf <- cbind(Name=bafs_diplo_df$mks, Chr = chr, Position = pos, bafs_diplo_df[,-1])


baf <- baf[-which(grepl("CHLOROPLAST", baf$Chr) | grepl("CH00", baf$Chr)),]
baf <- baf[-which(is.na(baf$Chr) | baf$Chr == "0"),]

vroom_write(baf, file = "baf_potato_texas_round2.txt.gz")

# logR <- cbind(Name=logRs_diplod_m$mks, Chr = chr, Position = pos, logRs_diplod_m[,-1])
# logR <- logR[-which(is.na(logR$Chr)| logR$Chr == "0"),]
# logR <- vroom("data/potato/logR_potato_texas.txt")
# logR <- logR[,-4]
# logR <- logR[-which(grepl("CHLOROPLAST", logR$Chr) | grepl("CH00", logR$Chr)),]
#vroom_write(logR, file = "logR_potato_texas_round2.txt")

```



# Roses France

```{r}

```

